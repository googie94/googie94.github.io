---
layout: post
author: "googie"
title:  "프로그래머를 위한 파이썬(1)"
subtitle: "사내 스터디가 생겼다"
type: "Python"
tech: true
text: true
post-header: true
header-img: "img/python_pro.png"
order: 6
comments: false
draft: false
lastmod: 2023-07-08 22:00:00
---

### 사내 스터디가 생겼다.


이름하야 `흐지부지..` 흐지부지 하지 않겠다는 다짐에서 나왔다.
역할도 나누어서, 각자가 미리 준비해야 스터디에 문제없이 참가할 수 있다.
요약하는 요약지기, 좀 더 깊이 탐구하는 심화지기, 질문지기, 그 날 내용을 정리하는 서기지기, 지난 내용을 복기하는 복습지기가 있다.



![흐지부지 스터디](img/흐지부지_초대장.png)
<span class="image_desc">흐지부지 스터디 초대장</span>


### 더 큰 그림

새로운 주제를 배울때는 큰 그림을 바탕으로 생각을 쌓아가며 집중하는 것이 중요하다.
왜 현대 소프트웨어 개발에서 파이썬이 왜 중요한지, 프로그래밍 실력을 키워줄 설계 원칙을 이해하는 초석을 다진다.


개발자들은 파이썬의 성능과 적용성을 부정적으로 평가하곤 했다.
파이썬은 작은 규모의 데이터 처리 작업이나 개인적인 도구를 만들고, 엔터프라이즈 소프트웨어를 개발할때는 자바, C 등이 사용되었다.
하지만, 지금의 파이썬은 로봇 공학에서부터 머신러닝까지, 그리고 성공한 엔터프라이즈에서도 파이썬을 도입하고 있다.


인스타그램의 개발자인 '후이 딩'은 "빠른 성능이 더 이상 주된 관심사가 아니다. 시장의 속도가 더 중요하다." 라고 했다.
파이썬은 다른 문법에 비해 장황하지 않고 영어 문법에 가까워 이해하기 쉽다.
또한, 프로토타이핑을 빠르게 해주며 소프트웨어를 견고하고 유지보수 할 수 있는 코드로 만들어주는 능력을 제공한다.

<br>

---

### 관심사는 무엇이고, 왜 관심사를 분리해야 하는가.

관심사는 `소프트웨어가 다루는 독립적인 행동이나 정보`이다. 관심사를 분리하는 이유는 `명확한 코드`를 만들기 위해서다.
명확한 코드의 초석은 여러 기능을 관리할 수 있는 작은 조각으로 나누는 것이고, 명확한 코드는 머리를 쓰지 않아도 쉽게 이해되는 코드다.


파이썬 모듈은 코드를 가지고 있는 `.py`의 파일을 의미한다.
각 모듈은 모듈 내부의 코드에 접근할 수 있는 네임스페이스를 갖는다.

```python
# football.py

# 전역 네임 스페이스
FOOTBALL_POSITION = {
    "Goalkeeper": "GK",
    "Defender": "DF",
    "Midfielder": "MD",
    "Forward": "FW",
}

def get_player_short_position(player, key):
    # 로컬 네임 스페이스
    player_short_position = FOOTBALL_POSITION(key)
    return player_short_position
```
<span class="image_desc">전역, 로컬 네임 스페이스</span>


네임스페이스의 우선 순위는, 파이썬 내장 > 모듈 전역 > 클래스 > 메서드 순으로 우선되며, 오버라이드 된다.

<br>

---

### 파일의 연결

분리된 파이썬 모듈을 가져다 쓰고 싶을때, 우리는 `import` 구문을 사용한다. 임포트에는 다양한 방법이 있다.

```python
# league.py

# 함수 하나를 가져오기
from football import get_player_short_position

# 여러 함수를 가져오기
from football import (
    get_player_short_position,
    get_player_long_position,
    get_player
)

# 전체를 명시적으로 가져오기
import football

# 전체를 가져오기
from football import *
```
<span class="image_desc">다양한 임포트 방법</span>

>
from 모듈명 import * 구문을 사용하면 모듈에 있는 모든것을 임포트한다. 절대로 이렇게 하지 말자.
임포트된 이름을 명시적으로 볼 수 없기 때문에 디버깅에 어렵고, 네임 스페이스의 충돌을 야기한다.

<br>

---

### 네임스페이스는 충돌을 방지한다.

파이썬은 자신이 아는 가장 최신의 정의를 사용한다. 충돌이 일어나면 최신의 것으로 덮어씌워진다는 것이다.

```python
from time import time
from datetime import time

# time 네임스페이스에서 충돌이 일어났고,
# 가장 최신의 것인 datetime 모듈의 time 으로 덮어씌워졌다.
print(time)
```
<span class="image_desc">네임스페이스의 충돌</span>
<br>
```python
# 명시적인 네임스페이스 사용
import time
import datetime

print(time())
print(datetime.time())

# 서브파티 라이브러리 사용으로 인한 충돌 시, as 구문 사용
import datetime
from library import datetime as lib_datetime

print(datetime.time())
print(lib_datetime.time())
```
<span class="image_desc">명시적인 네임스페이스 사용</span>

특별한 이유가 없다면, 파이썬 내장 함수를 오버라이드 하지 말자.
만든 모듈의 이름을 바꾸거나, 전체 코드에서 해당 모듈을 참조하는 부분을 찾아 바뀐 이름으로 업데이트 하는 것을 권장한다.

<br>

---

### 관심사의 분리

> 관심사 분리의 목표는 비슷한 동작을 함께 묶으며, 서로 다른 동작은 독립적으로 격리하는 것이다.


관심사 분리를 구성하고 유지하기 위해 사용하는 구조적 도구로는 `패키지`, `모듈`, `클래스`, `함수`가 있다.

```python

game/ # 패키지
 ├── __init__.py # 이 파일은 보통 비어있다. 특정 디렉터리를 패키지처럼 취급하라고 파이썬에게 알려주는 파일이다.
 ├── football.py # 모듈
 ├── league.py  # 모듈

# football.py - 모듈

class Position: # 클래스
    def __init__(self, user):
        self.user = user

    def get_short_position(self, user): # 함수
        ...
```
<span class="image_desc">관심사를 분리하기 위한 파이썬 도구</span>


함수
>
- 가장 쉽게 접근할 수 있는 도구.
- 관심사에 따라 코드를 신중하게 분해하고 수행하는 작업에 맞게 명시적으로 이름을 준다면 가독성을 향상시킬 수 있다.
- 코드의 길이는 그리 중요하지 않다.
- `설계 ➡︎ 리팩토링 ➡︎ 분해 ➡︎ 관심사 분리`의 과정은 개발 과정을 건강하게 한다.

<br>

클래스
>
- 어떤 함수의 결과를 다른 함수로 전달해야 하거나, 여러 함수가 동일한 입력 데이터를 받고 있다면 클래스를 적용할 시기이다.
- 클래스의 메서드와 속성이 밀접하게 관련되면 코드의 `응집력(cohesion)` 이 높다고 말한다.
- 클래스의 내용이 전체적으로 하나로 뭉쳐지면 응집력이 생긴다.
- 클래스는 높은 응집력을 갖는것이 좋다.
- 반대로, 어떤 클래스가 다른 클래스에 의존적이라면 이 클래스는 `결합(coupled)` 되었다고 한다.
- 한쪽을 수정한다면 다른 쪽도 수정해야하므로 이들 클래스는 서로 `강하게` 결합된 것이다.
- 우리는 항상 `느슨한(loose)` 결합을 추구해야 한다.

<br>

모듈
>
- 코드가 잘 분리되어 명확한 이름을 가진 함수, 클래스, 메서드로 나눴더라도 하나의 파일(모듈)에 있는 것은 바람직하지 않다.
- 동작을 기억할 수 있는 카테고리로 나눠야한다.
- 범주(카테고리)가 무엇인지를 추측하는 일은 보수적으로 조심스럽게 해야한다.
- 개발 초기에는 예측한 시스템의 모델은 계속 진화하고 개선됨에 따라 계속해서 변경될 것이기 때문이다.

<br>

패키지
>
- 코드 계층 구조를 확장시켜 찾기 쉽고 내용을 쉽게 이해할 수 있는 구조를 만들 수 있다.
- 각 패키지는 상위 개념의 관심사를 해결하며 패키지에 포함된 각 모듈은 그보다 더 작은 관심사를 관리한다.
- 각 모듈에 있는 클래스, 메서드, 함수는 애플리케이션의 각 부분을 명확하게 해준다.

<br>

---

### 요약

- 관심사 분리는 이해할 수 있는 코드를 만드는 핵심
- 함수를 작성할때, 명확성과 분리가 1차 목표이다. 재사용성은 부가적인 목표가 되어야 한다.
- 클래스는 밀접하게 관련한 동작과 데이터를 객체로 그룹화한다.
- 모듈은 독립적인 관심사 분리를 유지하면서 관련 클래스, 함수, 데이터를 그룹화한다.
- 모듈의 계층 구조는 모듈의 이름을 짓거나 해당 코드를 쉽게 발견하는 데 도움을 주며, 패키지는 모둘의 계층구조를 생성하는 데 도움을 준다.

<br>

---

### 심화


<p><strong>from module import *</strong></p>

놀랍게도 우리가 만든 코드 내에서도 `from module import *`가 존재했다.
이번 스터디를 통해 명시적으로 변경했고, 책에서 말한 네임스페이스의 충돌 가능성과 디버깅의 어려움을 공감했다.

<br>

<p><strong>관심사 분리</strong></p>

일부 잘 지켜지지 않은`(응집력이 부족한)` 모듈이 존재했다.
초기엔 프로젝트 내 공통으로 사용할 함수를 담을 용도로 만들어졌지만, 이제는 너무나 다양한 관심사를 가지고 있는 모듈이 되어 버렸다.
각 패키지 별로 관심사를 분리할 필요가 있다.


---

### 질문


| 질문 | 응답 |
| :---: | :---: |
| `단일책임원칙과 관심사가 뭐가 다를까요? 저는 비슷하게 느껴졌어요.` | 단일책임원칙은 하나의 함수는 하나의 기능만 한다.<br><br>관심사는 여러 것들이 혼재 되어 있는 상황에 같은 관심사끼리 묶여야 한다.<br><br>단일 책임 원칙은 하나의 클래스가 다른 클래스로 변화할 이유는 오로지 한 개여야 한다.<br><br>관심사는 조금 더 넓은 의미로, 조금 더 아키텍쳐 관점으로 기능별 프로그램을 분리시키는 디자인 원칙이다. |
| `네임스페이스에 대한 정확한 정의를 알려주지 않았어요. 섭섭해서 찾아봤어요.` | 소속을 구분할 수 있는 범위를 말해요.<br><br>예를 들자면, A강아지가 멍멍멍 짖는 것과, B강아지가 멍멍멍 짖는 것을 어떻게 구분할까요?<br><br>소속이 있어야 해요. A강아지가 멍멍멍 짖었다. 라고요. 이런게 메인 스페이스가 객체를 구분할 수 있는 범위를 말하는 거예요. |
| `책에서는 네임스페이스의 이점에 “충돌을 방지한다”라고 되어 있어요. 그런데 충돌이 나는 상황을 만드려고 해도 만들어 지지 않았어요.` | 파이썬은 같은 변수명을 사용했을때, 가장 최신의 것을 따르기 때문에 충돌은 나지만 에러를 뱉진 않는 것 같아요. 충돌이라기보단 덮어씌워진다에 가깝다 라고 생각이 들어요.<br><br>번역자가 파이썬을 안써본 사람이 아닐까요?<br><br>충돌보단 덮어씌워진다가 더 맞는 표현인 것 같아요. 제가 생각한 충돌은 실행이 안된다로 이해했거든요. |

